-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0.  If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.
--
-- Copyright 1997 - July 2008 CWI, August 2008 - 2017 MonetDB B.V.

-- (co) Arjen de Rijke, Bart Scheers
-- Use statistical functions from rmath library

divert(`-1')
define(`DIST1FUNCTION',`-- $1 distribution
FUNCTION4($1 cumulative density function,p$2,double,q,double,$3,integer,lower,integer,log)
FUNCTION4($1 quantile function,q$2,double,p,double,$3,integer,lower,integer,log)
FUNCTION3($1 probability density function,d$2,double,p,double,$3,integer,log)
FUNCTION1($1 random numbers,r$2,double,$3)
')

define(`DIST2FUNCTION',`-- $1 distribution
FUNCTION5($1 cumulative density function,p$2,double,q,double,$3,double,$4,integer,lower,integer,log)
FUNCTION5($1 quantile function,q$2,double,p,double,$3,double,$4,integer,lower,integer,log)
FUNCTION4($1 probability density function,d$2,double,p,double,$3,double,$4,integer,log)
FUNCTION2($1 random numbers,r$2,double,$3,double,$4)
')

define(`DIST3FUNCTION',`-- $1 distribution
FUNCTION6($1 cumulative density function,p$2,double,q,double,$3,double,$4,double,$5,integer,lower,integer,log)
FUNCTION6($1 quantile function,q$2,double,p,double,$3,double,$4,double,$5,integer,lower,integer,log)
FUNCTION5($1 probability density function,d$2,double,p,double,$3,double,$4,double,$5,integer,log)
FUNCTION3($1 random numbers,r$2,double,$3,double,$4,double,$5)
')

define(`FUNCTION0',`-- $1
create function r_$2()
returns double
language c {
#define MATHLIB_STANDALONE
#include "Rmath.h"
#pragma CFLAGS DCFLAGS
#pragma LDFLAGS DLDFLAGS
    result->initialize(result, 1);
    result->data[0] = $2;
};
')
define(`FUNCTION1',`-- $1
create function r_$2($4 $3)
returns double 
language c {
#define MATHLIB_STANDALONE
#include "Rmath.h"
#pragma CFLAGS DCFLAGS
#pragma LDFLAGS DLDFLAGS
    result->initialize(result, $4.count);
    for(size_t i_ = 0; i_ < $4.count; i_++) {
        if ($4.is_null($4.data[i_])) {
            result->data[i_] = result->null_value;
        } else {
            result->data[i_] = $2($4.data[i_]);
        }
    }
};
')
define(`FUNCTION2',`-- $1
create function r_$2($4 $3, $6 $5)
returns double 
language c {
#define MATHLIB_STANDALONE
#include "Rmath.h"
#pragma CFLAGS DCFLAGS
#pragma LDFLAGS DLDFLAGS
    size_t n1_ = $4.count>1;
    size_t n2_ = $6.count>1;
    size_t n_ = $4.count>$6.count ? $4.count : $6.count;
    result->initialize(result, n_);
    for(size_t i_ = 0; i_ < n_; i_++) {
        if ($4.is_null($4.data[i_*n1_]) || $6.is_null($6.data[i_*n2_])) {
            result->data[i_] = result->null_value;
        } else {
            result->data[i_] = $2($4.data[i_*n1_],$6.data[i_*n2_]);
        }
    }
};
')
define(`FUNCTION3',`-- $1
create function r_$2($4 $3, $6 $5, $8 $7)
returns double 
language c {
#define MATHLIB_STANDALONE
#include "Rmath.h"
#pragma CFLAGS DCFLAGS
#pragma LDFLAGS DLDFLAGS
    size_t n1_ = $4.count>1;
    size_t n2_ = $6.count>1;
    size_t n3_ = $8.count>1;
    size_t n_ = $4.count>$6.count ? $4.count : $6.count;
    if ($8.count>n_) n_ = $8.count;
    result->initialize(result, n);
    for(size_t i_ = 0; i_ < n_; i_++) {
        if ($4.is_null($4.data[i_*n1_]) || $6.is_null($6.data[i_*n2_]) || $8.is_null($8.data[i_*n3_])) {
            result->data[i_] = result->null_value;
        } else {
            result->data[i_] = $2($4.data[i_*n1_],$6.data[i_*n2_],$8.data[i_*n3_]);
        }
    }
};
')
define(`FUNCTION4',`-- $1
create function r_$2($4 $3, $6 $5, $8 $7, $10 $9)
returns double 
language c {
#define MATHLIB_STANDALONE
#include "Rmath.h"
#pragma CFLAGS DCFLAGS
#pragma LDFLAGS DLDFLAGS
    size_t n1_ = $4.count>1;
    size_t n2_ = $6.count>1;
    size_t n3_ = $8.count>1;
    size_t n4_ = $10.count>1;
    size_t n_ = $4.count>$6.count ? $4.count : $6.count;
    if ($8.count>n_) n_ = $8.count;
    if ($10.count>n_) n_ = $10.count;
    result->initialize(result, n_);
    for(size_t i_ = 0; i_ < n_; i_++) {
        if ($4.is_null($4.data[i_*n1_]) || $6.is_null($6.data[i_*n2_]) || $8.is_null($8.data[i_*n3_]) || $10.is_null($10.data[i_*n4_])) {
            result->data[i_] = result->null_value;
        } else {
            result->data[i_] = $2($4.data[i_*n1_],$6.data[i_*n2_],$8.data[i_*n3_],$10.data[i_*n4_]);
        }
    }
};
')
define(`FUNCTION5',`-- $1
create function r_$2($4 $3, $6 $5, $8 $7, $10 $9, $12 $11)
returns double 
language c {
#define MATHLIB_STANDALONE
#include "Rmath.h"
#pragma CFLAGS DCFLAGS
#pragma LDFLAGS DLDFLAGS
    size_t n1_ = $4.count>1;
    size_t n2_ = $6.count>1;
    size_t n3_ = $8.count>1;
    size_t n4_ = $10.count>1;
    size_t n5_ = $12.count>1;
    size_t n_ = $4.count>$6.count ? $4.count : $6.count;
    if ($8.count>n_) n_ = $8.count;
    if ($10.count>n_) n_ = $10.count;
    if ($12.count>n_) n_ = $12.count;
    result->initialize(result, n_);
    for(size_t i_ = 0; i_ < n_; i_++) {
        if ($4.is_null($4.data[i_*n1_]) || $6.is_null($6.data[i_*n2_]) || $8.is_null($8.data[i_*n3_]) || $10.is_null($10.data[i_*n4_]) || $12.is_null($12.data[i_*n5_])) {
            result->data[i_] = result->null_value;
        } else {
            result->data[i_] = $2($4.data[i_*n1_],$6.data[i_*n2_],$8.data[i_*n3_],$10.data[i_*n4_],$12.data[i_*n5_]);
        }
    }
};
')
define(`FUNCTION6',`-- $1
create function r_$2($4 $3, $6 $5, $8 $7, $10 $9, $12 $11, $14 $13)
returns double 
language c {
#define MATHLIB_STANDALONE
#include "Rmath.h"
#pragma CFLAGS DCFLAGS
#pragma LDFLAGS DLDFLAGS
    size_t n1_ = $4.count>1;
    size_t n2_ = $6.count>1;
    size_t n3_ = $8.count>1;
    size_t n4_ = $10.count>1;
    size_t n5_ = $12.count>1;
    size_t n6_ = $14.count>1;
    size_t n_ = $4.count>$6.count ? $4.count : $6.count;
    if ($8.count>n_) n_ = $8.count;
    if ($10.count>n_) n_ = $10.count;
    if ($12.count>n_) n_ = $12.count;
    if ($14.count>n_) n_ = $14.count;
    result->initialize(result, n);
    for(size_t i_ = 0; i_ < n_; i_++) {
        if ($4.is_null($4.data[i_*n1_]) || $6.is_null($6.data[i_*n2_]) || $8.is_null($8.data[i_*n3_]) || $10.is_null($10.data[i_*n4_]) || $12.is_null($12.data[i_*n5_]) || $14.is_null($14.data[i_*n6_])) {
            result->data[i_] = result->null_value;
        } else {
            result->data[i_] = $2($4.data[i_*n1_],$6.data[i_*n2_],$8.data[i_*n3_],$10.data[i_*n4_],$12.data[i_*n5_],$14.data[i_*n6_]);
        }
    }
};
')

divert(`1')

FUNCTION0(e,M_E)
FUNCTION0(log2(e),M_LOG2E)
FUNCTION0(log10(e),M_LOG10E)
FUNCTION0(ln(2),M_LN2)
FUNCTION0(ln(10),M_LN10)
FUNCTION0(pi,M_PI)
FUNCTION0(2*pi,M_2PI)
FUNCTION0(pi/2,M_PI_2)
FUNCTION0(pi/4,M_PI_4)
FUNCTION0(1/pi,M_1_PI)
FUNCTION0(2/pi,M_2_PI)
FUNCTION0(2/sqrt(pi),M_2_SQRTPI)
FUNCTION0(sqrt(2),M_SQRT2)
FUNCTION0(1/sqrt(2),M_SQRT1_2)
FUNCTION0(sqrt(3),M_SQRT_3)
FUNCTION0(sqrt(32),M_SQRT_32)
FUNCTION0(log10(2),M_LOG10_2)
FUNCTION0(sqrt(pi),M_SQRT_PI)
FUNCTION0(1/sqrt(2pi),M_1_SQRT_2PI)
FUNCTION0(sqrt(2/pi),M_SQRT_2dPI)
FUNCTION0(log(2*pi),M_LN_2PI)
FUNCTION0(log(pi)/2,M_LN_SQRT_PI)
FUNCTION0(log(2*pi)/2,M_LN_SQRT_2PI)
FUNCTION0(log(pi/2)/2,M_LN_SQRT_PId2)
FUNCTION2(R_pow,R_pow,double,x,double,y)
FUNCTION2(R_pow_di,R_pow_di,double,x,int,y)
FUNCTION0(Normal random numbers,norm_rand)
FUNCTION0(Uniform random numbers,unif_rand)
FUNCTION0(Exponential random numbers,exp_rand)

-- create function rmath.set_seed(a integer, b integer)
-- returns double external name rmath."set_seed";

-- void	get_seed(unsigned int *, unsigned int *);

DIST2FUNCTION(Normal,norm,mean,sd)
DIST2FUNCTION(Uniform,unif,min,max)
DIST2FUNCTION(Gamma,gamma,shape,scale)
FUNCTION1(log1pmx,log1pmx,double,x)
FUNCTION1(log1pexp,log1pexp,double,x)
FUNCTION1(lgamma1p,lgamma1p,double,x)
FUNCTION2(logspace_add,logspace_add,double,logx,double,logy)
FUNCTION2(logspace_sub,logspace_sub,double,logx,double,logy)

-- double  logspace_sum(const double *, int);

DIST2FUNCTION(Beta,beta,shape1,shape2)
DIST2FUNCTION(Log-normal,lnorm,meanlog,sdlog)
DIST1FUNCTION(Chi-squared,chisq,df)
DIST2FUNCTION(Non-central chi-squared,nchisq,df,ncp)
DIST2FUNCTION(F,f,df1,df2)
DIST1FUNCTION(T,t,df)
DIST2FUNCTION(Binomial,binom,size,prob)

-- void	rmultinom(int, double*, int, int*);

DIST2FUNCTION(Cauchy,cauchy,location,scale)
DIST1FUNCTION(Exponential,exp,rate)
DIST1FUNCTION(Geometric,geom,prob)
DIST3FUNCTION(Hypergeometric,hyper,m,n,k)

DIST2FUNCTION(Negative Binomial,nbinom,size,prob)
DIST1FUNCTION(Poisson,pois,lambda)

DIST2FUNCTION(Weibull,weibull,shape,scale)
DIST2FUNCTION(Logistic,logis,location,scale)

-- # DIST3FUNCTION(nbeta,shape1,shape2,ncp)


FUNCTION6(Non-central beta cumulative distribution function,pnbeta,double,q,double,shape1,double,shape2,double,ncp,int,lower,int,log)
FUNCTION6(Non-central beta quantile function,qnbeta,double,p,double,shape1,double,shape2,double,ncp,int,lower,int,log)
FUNCTION5(Non-central beta probability density function,dnbeta,double,x,double,shape1,double,shape2,double,ncp,int,log)

-- # FUNCTION3(rnbeta,double,shape1,double,shape2,double,ncp)
-- # DIST3FUNCTION(nf,df1,df2,ncp)

FUNCTION6(Non-central F cumulative distribution function,pnf,double,q,double,df1,double,df2,double,ncp,int,lower,int,log)
FUNCTION6(Non-central F quantile function,qnf,double,p,double,df1,double,df2,double,ncp,int,lower,int,log)
FUNCTION5(Non-central F probability density function,dnf,double,x,double,df1,double,df2,double,ncp,int,log)
-- # DIST2FUNCTION(nt,df,ncp)
FUNCTION5(Non-central Student t cumulative distribution function,pnt,double,q,double,df,double,ncp,int,lower,int,log)
FUNCTION5(Non-central Student t quantile function,qnt,double,p,double,df,double,ncp,int,lower,int,log)
FUNCTION4(Non-central Student t probability density function,dnt,double,x,double,df,double,ncp,int,log)
FUNCTION6(Studentised rangecumulative distribution function,ptukey,double,q,double,nmeans,double,df,double,nranges,int,lower,int,log)
FUNCTION6(Studentised range quantile function,qtukey,double,p,double,nmeans,double,df,double,nranges,int,lower,int,log)
DIST2FUNCTION(Wilcoxon rank sum,wilcox, m, n)
DIST1FUNCTION(Wilcoxon signed rank,signrank,n)
FUNCTION1(gammafn,gammafn,double,x)
FUNCTION1(lgammafn,lgammafn,double,x)

-- double  lgammafn_sign(double, int*);
-- void    dpsifn(double, int, int, int, double*, int*, int*);

FUNCTION2(psigamma,psigamma,double,x,double,y)
FUNCTION1(digamma,digamma,double,x)
FUNCTION1(trigamma,trigamma,double,x)
FUNCTION1(tetragamma,tetragamma,double,x)
FUNCTION1(pentagamma,pentagamma,double,x)
FUNCTION2(beta,beta,double,x,double,y)
FUNCTION2(lbeta,lbeta,double,x,double,y)
FUNCTION2(choose,choose,double,n,double,k)
FUNCTION2(lchoose,lchoose,double,n,double,k)
FUNCTION3(bessel_i,bessel_i,double,x,double,nu,double,scaled)
FUNCTION2(bessel_j,bessel_j,double,x,double,nu)
FUNCTION3(bessel_k,bessel_k,double,x,double,nu,double,scaled)
FUNCTION2(bessel_y,bessel_y,double,x,double,nu)

-- double	bessel_i_ex(double, double, double, double *);
-- double	bessel_j_ex(double, double, double *);
-- double	bessel_k_ex(double, double, double, double *);
-- double	bessel_y_ex(double, double, double *);
-- # FUNCTION2(pythag,double,x,double,y)
-- int	imax2(int, int);
-- int	imin2(int, int);

FUNCTION2(fmax2,fmax2,double,x,double,y)
FUNCTION2(fmin2,fmin2,double,x,double,y)
-- # FUNCTION1(sign,sign,double,x)
FUNCTION2(fprec,fprec,double,x,double,y)
FUNCTION2(fround,fround,double,x,double,y)
FUNCTION2(fsign,fsign,double,x,double,y)
FUNCTION1(ftrunc,ftrunc,double,x)

-- # FUNCTION1(log1pmx,double,x) -- repeated
-- # FUNCTION1(lgamma1p,double,x) -- repeated
-- double cospi(double);
-- double sinpi(double);
-- double tanpi(double);
-- rmath_export double NA_REAL;
-- rmath_export double R_PosInf;
-- rmath_export double R_NegInf;
-- rmath_export int N01_kind;

-- FUNCTION3(Exact Poisson confidence interval,poisson_ci,double,x,integer,boundary,double,conflevel)
-- create function rmath.poisson_ci(x double, boundary integer)
-- returns double begin return poisson_ci(x,boundary,0.95); end;

-- create function rmath.poisson_cis(x double, conflevel double)
-- returns table(lci double, uci double)
-- external name rmath."poisson_cis";

-- create function rmath.poisson_cis2(x double, conflevel double)
-- returns table(lci double, uci double)
-- external name rmath."poisson_cis2";

-- -- deprecated call
-- create function rmath.poissonci(x double, boundary integer, conflevel double)
-- returns double begin return poisson_ci(x,boundary,conflevel); end;

-- -- deprecated call
-- create function rmath.poissonci(x double, boundary integer)
-- returns double begin return poisson_ci(x,boundary,0.95); end;

-- -- alternative: 0=left, 1=right, 2=two-sided
-- FUNCTION4(Poisson test,poisson_test,double,x,double,t,double,r,int,alternative);

-- create function rmath.poisson_test(x double, t double, r double)
-- returns double begin return poisson_test(x,t,r,2); end;

-- create function rmath.poisson_test(x double, t double)
-- returns double begin return poisson_test(x,t,1.0,2); end;

